<!DOCTYPE html>
<html lang="en">
<head>
    <title>Basic Example</title>
    <link rel="stylesheet" href="style/datepickerstyle.css"/>
    <link rel="stylesheet" href="style/style.css"/>
    <!--
	    <script src="https://unpkg.com/ag-grid-community/dist/ag-grid-community.min.js"></script>
    -->
    <script src="js/agGrid.js"></script>
    <link rel="stylesheet" href="style/uPlot.min.css">
    <script src="js/uPlotLib.js"></script>
    <script src="js/utils.js"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
</head>
<body>
	<script >
	    function swapTab(tabNumber, e) {
		let target = null;
		let tabs = document.querySelectorAll('.tabbody');
		for (let i = 0; i < tabs.length; i++) {
		    if( tabs[i].dataset.tabNumber === tabNumber) { target = tabs[i] }
		    tabs[i].classList.remove("tabactive")
		    tabs[i].classList.add("tabinactive")
		}
		target.classList.remove("tabinactive");
		target.classList.add("tabactive");
	    }
	    const recurseParents = (element, testFunction, store) => {
		if (element === document.body) {
			return;
		} else if(testFunction(element)) {
			store.push(element);
			return;

		} 
		recurseParents(element.parentElement, testFunction, store);
	    }
	    const removeTab = (e) => {
	    	e = e || window.event;
	    	e.stopPropagation();
		let returnVal = [];
		recurseParents(e.target, (x) => 
		{
			console.log("classList", x.classList, " == ", x.classList.contains('tab'));
			return (x.classList.contains('tab'));
		}, returnVal)
		let tab = returnVal[0];
		let bodyID = "#body_" + tab.dataset.tabNumber;
		let tabBody = document.querySelector(bodyID);
		console.log("tab number", tab.dataset.tabNumber)
		console.log("tab body", tabBody)

		let nextActiveTab = tabBody.nextSibling;
		tabBody.remove()
		// ========================================
		// call destructor hooks to remove
		// any stored data relating to this tab, and remove line from uPlot
		// =======================================
		tab.remove();
		if(nextActiveTab.dataset.tabNumber) {
			swapTab(nextActiveTab.dataset.tabNumber);
		}
	    }
	</script>
	<div class="bodywrapper">
		<div class="navbar">
		</div>


		<div id="work_space" class="work_space">
			<div class="tabheader">
				<div id="addbutton" class="tab"><h6>+</h6></div>
				<div class="showchartbutton" x-data="{activeTitle: 'Table'}">
					<button onclick="showChart()" x-on:click="activeTitle = (activeTitle === 'Table') ? 'Chart' : 'Table'" x-text="activeTitle"></button>
				</div>
			</div>
			<div id="tabmenu" class="tabbody tabinactive" data-tab-number="placeholder">
				<button class="menubutton" >one</button>
				<button class="menubutton" >two</button>
				<button class="menubutton" >three</button>
				<button class="menubutton" >four</button>
			</div>
			<div class="tabbody tabinactive" data-tab-number="tab3">
			</div>
		</div>



		<div id="chart_panel" class="chartwrapper overlaydown">
			<div id="myChart" style="height: 100%; width:100%;"></div>
	</div> 


	</div>
	<!-- templates -->
	<div style="visibility: hidden;">
	<div id="templatebody" class="tabbody tabinactive" data-tab-number="tab1">
		<div class="sidepanel">
		</div>
		<div class="tabpanel">
			<div id="grid_panel" class="gridwrapper ag-theme-alpine">
			</div>
		</div>
	</div>

	
	<div id="templatelinetab" class="linetab">
		<div class="linetabremove tabinactive"></div>
		<div class="linetabadd tabinactive"></div>
		<div class="linetabexpand"></div>
	</div>

	<div id="templatetab" class="tab" data-tab-number="tab1"><h6>New</h6><button onclick="removeTab(event)">x</button></div>
	</div>


	<!-- templates -->
    <script type="module">


	// ================== selecting a root =====================
	    const recurseChildren = (htmlElement) => {
	    console.log("htmlElement ", htmlElement);
		if (htmlElement.children.length === 0) {
			return [htmlElement]
		};
		let allChildren = [];
		for (let i = 0; i < htmlElement.children.length; i++) {
			console.log("recursing with ", htmlElement.children[i]);
			let children = recurseChildren(htmlElement.children[i]);
			if (children) {
				allChildren.push(...children);
			}
		}
		allChildren.push(htmlElement);
		return allChildren;
	    }

	    function addLine(lineTab) {
	    	let tempNode = document.querySelector("#templatelinetab");
		let newNode = tempNode.cloneNode(true);
		let readyNode = initLineTab(newNode);
		readyNode.id = "linetab_" + (Math.floor(Math.random() * (999 - 100) + 100));
		lineTab.after(readyNode);
		//insertAfter
	    }

	    function initLineTab(lineTab) {
	    	let childs = lineTab.children
		let removerTab, addTab, expandTab;
		for (let i = 0; i < childs.length; i++) {
			if(childs[i].classList.contains("linetabremove")) {
				removerTab = childs[i];
			} else if(childs[i].classList.contains("linetabadd")) {
				addTab = childs[i];
			} else if(childs[i].classList.contains("linetabexpand")) {
				expandTab = childs[i];
			}
		}
		removerTab.addEventListener("click", () => {
			if(lineTab.parentNode.children.length === 1) {
				console.log('but dont');
				return;
			}
			lineTab.remove();
		});
		addTab.addEventListener("click", () => {
			addLine(lineTab);
			
		});
		expandTab.addEventListener("click", () => {
			if (addTab.classList.contains("tabinactive")) {
				addTab.classList.add("tabactive")
				removerTab.classList.add("tabactive")
				addTab.classList.remove("tabinactive")
				removerTab.classList.remove("tabinactive")
			} else {
				addTab.classList.add("tabinactive")
				removerTab.classList.add("tabinactive")
				addTab.classList.remove("tabactive")
				removerTab.classList.remove("tabactive")
			}
		});
		return lineTab;
	    }

	    function finalizeTab(element, e) {

		    let tempBody = document.querySelector("#templatebody");
		    let newBody = tempBody.cloneNode(true);
		    element.innerHTML = newBody.innerHTML;

		    //=====set up side panel=========
		    console.log("element panel", element);
		    let sidePanel = Array.prototype.map.call(element.children, (x) => { return (x.classList.contains("sidepanel") ? x : false)}).filter(x => !!x)[0];
		    console.log("side panel", sidePanel);
		    let tempNode = document.querySelector("#templatelinetab");
		    let newNode = tempNode.cloneNode(true);
		    let readyNode = initLineTab(newNode)
		    readyNode.id = "linetab_" + (Math.floor(Math.random() * (999 - 100) + 100));

		    sidePanel.appendChild(readyNode);
		    // ================= query database for current time period (today) ====================================================
		    // ================= filter data for just the columns we need on the server side?
		    // display sensor events  
let gridwrapper = document.querySelector('.gridwrapper');
const urlRead = 'http://localhost:8000/read/cbwTurnsTable';
var model = [
{ field: "time", filter: "agDateColumnFilter",
filterParams: {
// provide comparator function
comparator: function(filterLocalDateAtMidnight, cellValue) {
var dateTime = cellValue; var dateArray = dateTime.split('T'); var dateAsString = dateArray[0];
if (dateAsString == null) {return 0;}
// In the example application, dates are stored as dd/mm/yyyy
// We create a Date object for comparison against the filter date
var dateParts = dateAsString.split('-');
var day = Number(dateParts[2]);
var month = Number(dateParts[1]) - 1;
var year = Number(dateParts[0]);
var cellDate = new Date(year, month, day);
// Now that both parameters are Date objects, we can compare
if (cellDate < filterLocalDateAtMidnight) {return -1;} else if (cellDate > filterLocalDateAtMidnight) {
return 1;} return 0;}}}, { field: "assetKey", filter: "agSetColumnFilter"}, { field: "exitingProductID" }, { field: "enteringProductID" }];


let dataStore = { fullData: [], viewData: [], updateDataFunctions: [], updateViewFunctions: [], 
updateData: function(newData) { this.fullData = newData;
for (let i = 0; i < this.updateDataFunctions.length; i++) { this.updateDataFunctions[i](newData); }
},
updateView: function(newData) { this.viewData = newData;
for (let i = 0; i < this.updateViewFunctions.length; i++) { this.updateViewFunctions[i](newData); }
}
}

var columnDefs = model;

const setRowData = (newData) => { gridOptions.api.setRowData(newData); }
const resetView = () => { let reset = store.fullData; store.updateView(reset); }
document.addEventListener('keydown', function(event) { if (event.ctrlKey && event.key === 'z') { resetView(); } });
dataStore.updateDataFunctions.push(setRowData);
const gridOptions = { rowData: dataStore.fullData, columnDefs: columnDefs, defaultColDef: { flex: 1, editable: false, },
getRowId: (params) => { return Object.values(params.data)[0]; },
onFilterChanged: function() {
// ========== this needs to behave differently depending on if the filter effects the time window or not ====
// change to time window: complete re-generation of table? 
// change to other filters: call hooks to change saved filters, call uPlot to change displayed line data
console.log('onFilterChanged');
let activeRows = [];
gridOptions.api.forEachNodeAfterFilter((node, index) => {activeRows.push(node.data)});
setTimeout(() => dataStore.updateView(activeRows), 0);
},

};
//----------------------------------------------------
// lookup the container we want the Grid to use
var eGridDiv = gridwrapper;
// create the grid passing in the div to use together with the columns &amp; data we want to use
new agGrid.Grid(eGridDiv, gridOptions);
agGrid.simpleHttpRequest({url: urlRead}).then(function(data) { dataStore.updateData(data); dataStore.updateView(data); });
		    // ================= hook up data storage, initialize agGrid, pass new hook object to uPlot, etc========================

	    }
	    function initTabMenu(element) {
	
	    	element.setAttribute("style", "background-color: rgba(230,50,230);");
		let buttonList = recurseChildren(element).filter(x => x.classList.contains("menubutton"));
		for (let i = 0; i < buttonList.length; i++ ) {
			buttonList[i].addEventListener("click", finalizeTab.bind(null, element));
		}
	    	// hook up listeners if needed to store data / filters in the correct place
	    	return element;
	    }
	    function initTabChangeHandlers(tab) {
		tab.addEventListener("click", swapTab.bind(null, tab.dataset.tabNumber));
	    	return tab;
	    }
	    function addTab() {
		    let tabData = "tab" + (Math.floor(Math.random() * (9999 - 1000) + 1000));
		    let bodyID = "body_" + tabData;
		    let tabID = "tab_" + tabData;

		    // create and insert menu panel as a new tab body
		    let tempBody = document.querySelector("#tabmenu");
		    let newBody = tempBody.cloneNode(true);
		    newBody.dataset.tabNumber = tabData;
		    newBody.id = bodyID
		    let readyBody = initTabMenu(newBody);
		    tempBody.after(readyBody);

		    //create and insert new tab
		    let tempTab = document.querySelector("#templatetab");
		    let newTab = tempTab.cloneNode(true);
		    newTab.dataset.tabNumber = tabData;
		    newTab.id = tabID;
		    let readyTab = initTabChangeHandlers(newTab);
		    document.querySelector("#addbutton").after(readyTab);

		    // set new tab as active
		    swapTab(tabData);

		    //clone children of addtab
		    //create new tab + body with matching data-tab-number
		    //insert after addTab body, insert after addTab tab
			
			console.log("add tab");
	    }

	    let addButton = document.querySelector("#addbutton");
	    addButton.addEventListener("click", addTab);

	    //let testingArray = document.querySelectorAll('.sidepanel');
	    //for (let i = 0; i < testingArray.length; i++) {
	    //	let tempNode = document.querySelector("#templatelinetab");
	    //    let newNode = tempNode.cloneNode(true);
	    //    let readyNode = initLineTab(newNode);
	    //    readyNode.id = "linetab_" + (Math.floor(Math.random() * (999 - 100) + 100));
	    //	testingArray[i].appendChild(readyNode);
	    //}

	    

	    let tabs = document.querySelectorAll('.tab');
	    for (let i = 0; i < tabs.length; i++) {
	    	if( tabs[i].dataset.tabNumber ) {
			tabs[i].addEventListener("click", swapTab.bind(null, tabs[i].dataset.tabNumber));
		}
	    }
	//article.dataset.indexNumber    
	    // insert buttons
	    // buttons call query with different parameters
	    //query returns with data, modified before being appended to ground truth
	    // create and append ag Grid, agGrid needs a 'filters' object

	// ================== =====================

	   // import { generateTimeSeriesTable } from './js/timeSeriesTable.js';




	
	// ================== agGrid code
	 //document.addEventListener('DOMContentLoaded', generateTimeSeriesTable(model, urlRead, dataStore));
	// ================== agGrid code

</script>
</body>
</html>
