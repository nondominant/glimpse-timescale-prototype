<!DOCTYPE html>
<html lang="en">
<head>
    <title>Basic Example</title>
    <link rel="stylesheet" href="style/datepickerstyle.css"/>
    <link rel="stylesheet" href="style/style.css"/>
    <!--
	    <script src="https://unpkg.com/ag-grid-community/dist/ag-grid-community.min.js"></script>
    -->
    <script src="js/agGrid.js"></script>
    <link rel="stylesheet" href="style/uPlot.min.css">
    <script src="js/uPlotLib.js"></script>
    <script src="js/utils.js"></script>
</head>
<body>
	<div class="bodywrapper">
	<div class="navbar">
		<a href="/sensorEvent">Sensor Event</a>
		<a href="/resourceUsage">Resource Usage</a>
		<a href="/machineStatus">Machine Status </a>
		<a href="/location">Location</a>
		<a href="/cbwTurns">CBW Turns </a>
	</div>
	<div id="grid_panel" class="gridwrapper">
	<div class="inputrow">
		<button onclick="showChart()" style="display:flex;margin:1.5rem;">Show Chart</button>
	</div>
		<div id="myGrid" style="height: 50rem; width:75rem;" class="ag-theme-alpine"></div>
	</div>
	<div id="chart_panel" class="chartwrapper overlaydown">
		<div id="myChart" style="height: 50rem; width:75rem;"></div>
	</div>
	</div>
    <script type="module">
	    import { generateTimeSeriesTable } from './js/timeSeriesTable.js';


	    const urlRead = 'http://localhost:8000/read/cbwTurnsTable';
	    var model = [
	    {
	    	field: "time",
		filter: "agDateColumnFilter",
		filterParams: {
		    // provide comparator function
		    comparator: function(filterLocalDateAtMidnight, cellValue) {
		    	var dateTime = cellValue;
			var dateArray = dateTime.split('T');

		        var dateAsString = dateArray[0];

		        if (dateAsString == null) {
		    	return 0;
		        }

		        // In the example application, dates are stored as dd/mm/yyyy
		        // We create a Date object for comparison against the filter date
		        var dateParts = dateAsString.split('-');
		        var day = Number(dateParts[2]);
		        var month = Number(dateParts[1]) - 1;
		        var year = Number(dateParts[0]);
		        var cellDate = new Date(year, month, day);

		        // Now that both parameters are Date objects, we can compare
		        if (cellDate < filterLocalDateAtMidnight) {
		    	return -1;
		        } else if (cellDate > filterLocalDateAtMidnight) {
		    	return 1;
		        }
		        return 0;
		    }
		}
	    },
	    {
	    	field: "assetKey",
		filter: "agSetColumnFilter"
	    },
	    {
	    	field: "exitingProductID"
	    },
	    {
	    	field: "enteringProductID"
	    }
	    ];


	    let dataStore = {
	            fullData: [],
	            viewData: [],
	            updateDataFunctions: [],
	            updateViewFunctions: [],
	            updateData: function(newData) {
	        	    this.fullData = newData;
	        	    for (let i = 0; i < this.updateDataFunctions.length; i++) {
	        		this.updateDataFunctions[i](newData);
	        	    }
	            },
	            updateView: function(newData) {
	        	    this.viewData = newData;
	        	    for (let i = 0; i < this.updateViewFunctions.length; i++) {
	        		this.updateViewFunctions[i](newData);
	        	    }
	            }
	    }

	function wheelZoomPlugin(opts) {
		let factor = opts.factor || 0.75;

		let xMin, xMax, yMin, yMax, xRange, yRange;

		function clamp(nRange, nMin, nMax, fRange, fMin, fMax) {
			if (nRange > fRange) {
				nMin = fMin;
				nMax = fMax;
			}
			else if (nMin < fMin) {
				nMin = fMin;
				nMax = fMin + nRange;
			}
			else if (nMax > fMax) {
				nMax = fMax;
				nMin = fMax - nRange;
			}

			return [nMin, nMax];
		}

		return {
			hooks: {
				ready: u => {
					xMin = u.scales.x.min;
					xMax = u.scales.x.max;
					yMin = u.scales.y.min;
					yMax = u.scales.y.max;

					xRange = xMax - xMin;
					yRange = yMax - yMin;

					let over = u.over;
					let rect = over.getBoundingClientRect();

					// wheel drag pan
					over.addEventListener("mousedown", e => {
						if (e.button == 1) {
						//	plot.style.cursor = "move";
							e.preventDefault();

							let left0 = e.clientX;
						//	let top0 = e.clientY;

							let scXMin0 = u.scales.x.min;
							let scXMax0 = u.scales.x.max;

							let xUnitsPerPx = u.posToVal(1, 'x') - u.posToVal(0, 'x');

							function onmove(e) {
								e.preventDefault();

								let left1 = e.clientX;
							//	let top1 = e.clientY;

								let dx = xUnitsPerPx * (left1 - left0);

								u.setScale('x', {
									min: scXMin0 - dx,
									max: scXMax0 - dx,
								});
							}

							function onup(e) {
								document.removeEventListener("mousemove", onmove);
								document.removeEventListener("mouseup", onup);
							}

							document.addEventListener("mousemove", onmove);
							document.addEventListener("mouseup", onup);
						}
					});

				}
			}
		};
	}

	let uChart;
	function makeChart(data) {
		
		const { linear, stepped, bars, spline, spline2 } = uPlot.paths;
		const lineInterpolations = {
				linear:     0,
				stepAfter:  1,
				stepBefore: 2,
				spline:     3,
			//	spline2:    4,
			};

			const drawStyles = {
				line:      0,
				bars:      1,
				points:    2,
				barsLeft:  3,
				barsRight: 4,
			};

			// generate bar builder with 60% bar (40% gap) & 100px max bar width
			const _bars60_100   = bars({size: [0.6, 100]});
			const _bars100Left  = bars({size: [1], align:  1});
			const _bars100Right = bars({size: [1], align: -1});
			const _stepBefore   = stepped({align: -1}); //, ascDesc: true
			const _stepAfter    = stepped({align:  1}); //, ascDesc: true
			const _linear       = linear();
			const _spline       = spline();
		//	const _spline2      = spline2();

			function paths(u, seriesIdx, idx0, idx1, extendGap, buildClip) {
				let s = u.series[seriesIdx];
				let style = s.drawStyle;
				let interp = s.lineInterpolation;

				let renderer = (
					style == drawStyles.line ? (
						interp == lineInterpolations.linear     ? _linear :
						interp == lineInterpolations.stepAfter  ? _stepAfter :
						interp == lineInterpolations.stepBefore ? _stepBefore :
						interp == lineInterpolations.spline     ? _spline :
					//	interp == lineInterpolations.spline2    ? _spline2 :
						null
					) :
					style == drawStyles.bars ? (
						_bars60_100
					) :
					style == drawStyles.barsLeft ? (
						_bars100Left
					) :
					style == drawStyles.barsRight ? (
						_bars100Right
					) :
					style == drawStyles.points ? (
						() => null
					) : () => null
				);

				return renderer(u, seriesIdx, idx0, idx1, extendGap, buildClip);
			}
		console.time('chart');

		let opts = {
			title: "Click & Drag to Zoom",
			tzDate: ts => uPlot.tzDate(new Date(ts * 1e3), 'Etc/UTC'),
			tz: 'Etc/UTC',
			width: 1200,
			height: 800,
			plugins: [
				wheelZoomPlugin({factor: 0.75})
			],
			scales: {
			//	x: {
			//		time: false,
			//	},
			//	y: {
			//		auto: false,
			//	}
			},
			series: [
				{},
				{
					drawStyle:         3,
					lineInterpolation: null,
					stroke:            "red",
					fill:              "pink",
					label: "Y",
					paths,
				},
			],
			axes: [
			{
			space: 100,
			},
			{
			space: 20
			}
			]
		};


		let chartElement = document.getElementById('myChart');
		uChart = new uPlot(opts, data, chartElement);

		console.timeEnd('chart');
	}

	const data = [
		[],
		[],
		[],
	];
	makeChart(data);
	// ================== agGrid code
	const p = (newData, currentChart = uChart) => {
		console.log('updated data', newData);
		let timeStrings = newData.map((obj) => { return obj.time });
		let timeStamps = timeStrings.map((s) => { 
			let d = new Date(s);
			return Math.floor(d.getTime() / 1000);
		});

		let stepSize = {
			"min": 60,
			"hour": 3600,
			"day": 86400,
			"week": 604800,
		};

		let min = timeStamps[0];
		let rounded = new Date(min);
		rounded.setMinutes(0,0,0);
		min = rounded.getTime()

		let max = timeStamps[timeStamps.length -1];
	    	let step = stepSize["hour"];
		let ticks = [];
		let boundary = min;
		while (boundary < (max+step)) {
	    		ticks.push(boundary);
	    		boundary += step;
	        }

		let countIndex = 0;
		let counts = Array(timeStamps.length).fill(0);

	    	let i = 0;
		while ( i < timeStamps.length && countIndex < counts.length) {
	    		if(ticks[countIndex+1] === 'undefined') { break; }
	    		if(ticks[countIndex+1] == 'undefined') { break; }
	    		if(ticks[countIndex+1] == undefined) { break; }
	    		if(ticks[countIndex+1] === undefined) { break; }
	    if(countIndex > 1000) { break; }
			if (timeStamps[i] < ticks[countIndex+1]) {
				counts[countIndex] += 1;
	    			i ++;
			} else {
				countIndex ++;
			}
		}

		let outputArray = counts.filter((x) => { return (x > 0)});

		const testdata = [
			ticks,
			outputArray,
		];
		console.log('testdata', testdata);
		setTimeout(() => currentChart.setData(testdata), 0)
	}
	dataStore.updateViewFunctions.push(p);
	document.addEventListener('DOMContentLoaded', generateTimeSeriesTable(model, urlRead, dataStore));
	// ================== agGrid code
</script>
</body>
</html>
